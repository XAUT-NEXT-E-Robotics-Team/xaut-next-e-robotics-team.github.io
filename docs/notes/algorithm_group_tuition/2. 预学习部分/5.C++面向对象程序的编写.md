---
title: C++面向对象程序的编写
createTime: 2025/10/07 00:02:41
permalink: /docs/algorithm_group_tuition/xrfz95jd/
---
<!--
 *  _   _  _______   _______   _____  
 * | \ | ||  ___\ \ / /_   _| |  ___| 
 * |  \| || |__  \ V /  | |   | |__   
 * | . ` ||  __| /   \  | |   |  __|  
 * | |\  || |___/ /^\ \ | |   | |___  
 * \_| \_/\____/\/   \/ \_/   \____/  
 * 
 * @Author: ziyu (Chen Zhaoyu)
 * @Date: 2025-10-07 00:02:41
 * @LastEditors: ziyu (Chen Zhaoyu)
 * @LastEditTime: 2025-10-07 00:03:06
 * @Description: 
 * Copyright (c) 2025 by XAUT NEXT-E/ziyu, All Rights Reserved. 
-->

::: tip

本文仅提纲挈领的讲解了面向对象（oo）的相关思想和语法。建议结合系统性的教程理解内容。

:::

## 一、类和面向对象介绍

### 1.1 什么是面向对象？

大家学习c语言的时候会发现，main函数中程序是一步步进行的，c语言是面向过程的。那么如何定义一个包含所有相关属性的东西让我们很方便的调用呢？

**面向过程 vs 面向对象的本质区别：**

面向过程编程关注的是"步骤"——程序像菜谱一样，一步一步执行操作。数据和处理数据的函数是分离的。

面向对象编程关注的是"对象"——将相关的数据和操作这些数据的函数打包在一起，形成一个完整的实体。对象之间通过消息传递来进行交互。

‍

打个比方：我现在要制作一款游戏，假设为小狗的历险记，我们要将小狗的信息写下来作为一个对象

**传统面向过程：**

```C++
string name = "崔狗狗";
int age = 18;
double blood_volume = 100;

void printDogInfo(string name, int age, double score) {
    cout << "姓名：" << name << "，年龄：" << age << "，血量：" << blood volume;
}
```

‍

**面向对象思路：**

```C++
class Dog {  // 把小狗"封装"成一个整体
public:
    string name;
    int age;
    double blood_volume;
    
    void printInfo() {
        cout << "姓名：" << name << "，年龄：" << age << "，血量：" << blood volume;
    }
};
```

看懂上面的区别了吗？面向对象就是将相关的东西打包在一起，方便后面调用和继承
‍

## 二、一个简单的类

```C++
#include <iostream>
#include <string>
using namespace std;

// 定义一个类
class Dog {
public:  // 公共区域，外面可以访问
    string name;
    int age;
	double blood_volume;
    
    // 成员函数（方法）
    void introduce() {
        cout << "这是" << name << "，今年" << age << "岁，" << "现在血量为"<< blood_volume <<endl;
    }
};

int main() {
    // 创建对象（类的实例）
    Dog dog1;
    dog1.name = "崔狗狗";
    dog1.age = 18;
	dog1.blood_volume = 100;
    dog1.introduce();  // 输出：这是崔狗狗，今年18岁，现在血量为100
    
    return 0;
}
```

‍

## 三、调用权限

```C++
class Dog {
private:   // 私有，只有类内部能访问
    string password;

public:    // 公有，谁都能访问  
    string name;
    
protected: // 保护，类和子类能访问
    int DogId;
};
```

‍

## 四、成员函数、构造函数和析构函数

### 4.1成员函数

和c语言的函数很像，但是有所区别，在类里面定义，可以在类里面直接调用，也可以在类外面用类名.函数名(void/参数)调用

```C++
#include <iostream>
#include <string>
using namespace std;

class AdventureDog {
public:
    string name;
    int energy;
    
    // 成员函数：奔跑
	// 无参数
    void run() {
        if (energy >= 20) {
            energy -= 20;
            cout << name << " 快速奔跑！消耗20点能量" << endl;
            cout << "剩余能量：" << energy << endl;
        } else {
            cout << name << " 太累了，跑不动了！" << endl;
        }
    }

	// 成员函数2：吃东西
	// 有参数
    void eat(string food) {
        energy += 30;
        if (energy > 100) energy = 100;
        cout << name << " 吃了 " << food << "，恢复30点能量" << endl;
        cout << "当前能量：" << energy << endl;
    }
    
};

int main() {
    AdventureDog dog；
	dog.name = "雅雅";
	dog.energy = 100;
 
    // 调用成员函数：手动控制小狗行动
    dog.run();      // 奔跑
	dog.eat("骨头")；
	dog.run();      // 再跑一次
    
    return 0;
}
```

‍

### 4.2 构造函数

构造函数在创建一个对象时会**直接被调用，一般用于类的开头**

```C++
class Dog {
public:
    string name;
    int age;
    
    // 构造函数：创建对象时自动调用
    Dog() {
        cout << "创建了一个类" << endl;
        name = "崔狗狗";
        age = 18;
    }
    
    // 带参数的构造函数
    Dog(string n, int a) {
        name = n;
        age = a;
        cout << "小狗" << name << "被创建了！" << endl;
    }
};

int main() {
    Dog dog1;              // 调用无参构造函数
    Dog dog2("玲玲", 19);  // 调用带参构造函数
    
    return 0;
}
```

‍

### 4.3 析构函数

析构函数在类的对象销毁时自动调用，只调用一次

```C++
#include <iostream>
#include <string>
using namespace std;

class AdventureDog {
public:
    string name;
    // 析构函数
    ~AdventureDog() {
        cout << "🏠 小狗 " << name << " 回家休息了，明天继续冒险！" << endl;
    }
    
};

int main() {
    AdventureDog dog;
	dog.name =="崔狗狗" 
    // main函数结束时，dog对象的析构函数会自动调用
    
    return 0;
}
```

‍

### 4.4 综合使用

```C++
#include <iostream>
#include <string>
using namespace std;

class AdventureDog {
public:
    string name;
    int energy;
    
    // 构造函数
    AdventureDog(string dogName) {
        name = dogName;
        energy = 100;
        cout << "🐶 冒险小狗 " << name << " 加入游戏！" << endl;
    }
    
    // 析构函数
    ~AdventureDog() {
        cout << "🏠 小狗 " << name << " 回家休息了，明天继续冒险！" << endl;
    }
    
    // 成员函数1：奔跑
    void run() {
        if (energy >= 20) {
            energy -= 20;
            cout << name << " 快速奔跑！消耗20点能量" << endl;
            cout << "剩余能量：" << energy << endl;
        } else {
            cout << name << " 太累了，跑不动了！" << endl;
        }
    }
    
    // 成员函数2：吃东西
    void eat(string food) {
        energy += 30;
        if (energy > 100) energy = 100;
        cout << name << " 吃了 " << food << "，恢复30点能量" << endl;
        cout << "当前能量：" << energy << endl;
    }
    
    // 成员函数3：叫唤
    void bark() {
        cout << name << " 汪汪叫！🐕" << endl;
    }
    
};

int main() {
    // 创建小狗（构造函数自动调用）
    AdventureDog dog("崔狗狗");
    
    // 调用成员函数：手动控制小狗行动
    dog.bark();     // 叫唤
    dog.run();      // 奔跑
    dog.run();      // 再跑一次
    dog.eat("骨头"); // 吃东西
    dog.bark();     // 又叫唤
    
    // main函数结束时，dog对象的析构函数会自动调用
    
    return 0;
}
```

‍

## 五、this指针

this指针是指向自己的指针

```C++
class Dog {
public:
    string name;
    
    void setName(string name) {
        // 参数name和成员变量name重名了！
        this->name = name;  // this->name表示成员变量，name是参数
    }
    
    void printThis() {
        cout << "我的内存地址是：" << this << endl;
    }
};
```

‍

## 六、静态成员

### 6.1 静态成员变量

静态成员变量可以被所有对象所共享

```C++
class Dog {
public:
    string name;
    static int count;  // 静态成员，所有对象共享
    
    Dog(string n) {
        name = n;
        count++;  // 每创建一只小狗，计数加1
    }
};

// 静态成员在类外初始化
int Dog::count = 0;

int main() {
    Dog dog1("雅雅");
    Dog dog2("玲玲");
    
    cout << "小狗总数：" << Dog::count << endl;  // 输出：2
    
    return 0;
}
```

‍

### 6.2静态成员函数

静态成员函数可以被所有对象所共享

```C++
class Dog {
public:
    static int count;
    
    static void showCount() {
        cout << "当前小狗数：" << count << endl;
        // 注意：静态函数不能访问非静态成员！
    }
};
```

‍

## 七、继承

**继承**允许我们基于一个已有的类来定义一个新的类，新的类会"继承"原有类的特性，并可以添加自己的新特性

### 7.1 定义基类（父类）

```C++
// 基类（父类）
class Animal {
private:
    string name;
    int age;

public:
    // 构造函数
    Animal(string n, int a) : name(n), age(a) {}
    
    // 成员函数
    void eat() {
        cout << name << "正在吃东西..." << endl;
    }
    
    void sleep() {
        cout << name << "正在睡觉..." << endl;
    }
    
    // 获取私有成员的方法
    string getName() { return name; }
    int getAge() { return age; }
};
```

‍

### 7.2 定义派生类（子类）

继承方法：参考下文

```C++
// 派生类（子类）
class Dog : public Animal {  // public继承
private:
    string breed;  // 新品种：品种

public:
    // 派生类的构造函数
    Dog(string n, int a, string b) : Animal(n, a), breed(b) {}
    
    // 新功能：狗特有的行为
    void bark() {
        cout << getName() << "在汪汪叫！" << endl;
    }
    
    void displayInfo() {
        cout << "名字：" << getName() << ", 年龄：" << getAge() 
             << ", 品种：" << breed << endl;
    }
};
```

‍

### 7.3 继承的使用

```C++
int main() {
    // 创建基类对象
    Animal animal("小动物", 2);
    animal.eat();
    
    // 创建派生类对象
    Dog dog("雅雅", 3, "非洲小土狗");
    dog.eat();      // 继承自Animal
    dog.sleep();    // 继承自Animal  
    dog.bark();     // Dog自己的方法
    dog.displayInfo();
    
    return 0;
}
```

‍

### 7.4 不同的继承方法

##### 1. public继承（最常用）

```C++
class Derived : public Base {
    // 继承关系：
    // Base的public成员 → Derived的public成员
    // Base的protected成员 → Derived的protected成员
    // Base的private成员 → 不可访问
};
```

‍

##### 2. protected继承

```C++
class Derived : protected Base {
    // 继承关系：
    // Base的public成员 → Derived的protected成员
    // Base的protected成员 → Derived的protected成员
    // Base的private成员 → 不可访问
};
```

‍

##### 3. private继承

```C++
class Derived : private Base {
    // 继承关系：
    // Base的public成员 → Derived的private成员
    // Base的protected成员 → Derived的private成员
    // Base的private成员 → 不可访问
};
```

‍

### 7.5 构造函数和析构函数调用顺序

在C++继承体系中，构造函数的调用遵循一个明确而严格的顺序。当创建派生类对象时，系统会自动按照特定顺序调用各个相关类的构造函数。

基本调用原则：

构造函数的调用顺序遵循"从内到外，从基类到派生类"的原则。具体来说：

1. ​**最先调用基类的构造函数**：如果存在多层继承，则按照继承链从最顶层的基类开始，逐级向下调用
2. ​**接着调用成员对象的构造函数**：按照成员对象在类定义中声明的顺序依次调用
3. ​**最后调用派生类自身的构造函数**：执行派生类构造函数体中的代码

这种顺序确保了在构造派生类对象时，其依赖的基类部分和成员对象都已经被正确初始化，从而为派生类的构造提供了稳定的基础。

‍

```C++
class Base {
public:
    Base() { cout << "Base构造函数" << endl; }
    ~Base() { cout << "Base析构函数" << endl; }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived构造函数" << endl; }
    ~Derived() { cout << "Derived析构函数" << endl; }
};

// 使用：
int main() {
    Derived obj;
    return 0;
}

// 输出：
// Base构造函数
// Derived构造函数
// Derived析构函数
// Base析构函数
```

‍

### 7.6 函数重写与override

##### 7.6.1 **什么是函数重写？**

​**函数重写**（Function Overriding）是指派生类重新定义基类中的虚函数，提供自己特定的实现。

```C++
class Shape {
public:
    virtual void draw() {  // virtual关键字
        cout << "绘制形状" << endl;
    }
};

class Circle : public Shape {
public:
    void draw() override {  // override关键字（C++11）
        cout << "绘制圆形" << endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout << "绘制矩形" << endl;
    }
};
```

‍

##### 7.6.2 为什么要用override？

1. ​**提高代码可读性**：明确表示这是重写函数
2. ​**编译器检查**：确保正确重写，避免错误
3. ​**防止意外**：避免函数签名不匹配导致的隐藏而非重写

## 八、 其他资料

::: tip

如有不懂请先自行：STFW，RTFM

此处仍然推荐[黑马程序员](https://www.bilibili.com/video/BV1et411b73Z/)进行进一步学习

:::

## 九、 小任务（OOP + 多文件）

请完成以下练习：

1. 定义一个 `Student` 类，包含属性：姓名、学号
2. 提供 `displayInfo()` 方法，打印学生信息
3. 使用多文件结构组织：
  - `Student.h` → 类声明
  - `Student.cpp` → 类实现
  - `main.cpp` → 主程序

::: note 🔎 STFW：

- 搜索 `C++ 类与对象示例`、`C++ 多文件项目结构`
- 参考 GitHub 上的小型项目
::: 

::: tip
程序能正常运行比写得优雅更重要，后续再根据规范优化代码。

遵循代码规则的前提是能够正常运行。
:::

::: tip 小任务（本节的小任务需要提交）

**预学习答辩**将需要提交以下内容：

- 源代码（`.h/.hpp`、`.cpp`、`main.cpp` 等）
- 程序运行截图（正确输出学生信息）
- 一句话总结你对 **OOP + 多文件编程** 的理解

测评关注点：

- ✅ 能否写出基本类与对象
- ✅ 是否正确拆分头文件与实现文件
- ✅ 能否独立完成编译运行

💡 提示：即使代码不完善，也应提交尝试结果和遇到的问题记录。

:::

::: note 恭喜

如何你完成到这里，恭喜你已经成为了一个入门的C++程序员了。

:::