---
title: OpenCV简单使用
createTime: 2025/10/07 00:21:30
permalink: /docs/algorithm_group_tuition/bz2wnvxo/
---

<!--
 *  _   _  _______   _______   _____  
 * | \ | ||  ___\ \ / /_   _| |  ___| 
 * |  \| || |__  \ V /  | |   | |__   
 * | . ` ||  __| /   \  | |   |  __|  
 * | |\  || |___/ /^\ \ | |   | |___  
 * \_| \_/\____/\/   \/ \_/   \____/  
 * 
 * @Author: ziyu (Chen Zhaoyu)
 * @Date: 2025-10-07 00:21:30
 * @LastEditors: ziyu (Chen Zhaoyu)
 * @LastEditTime: 2025-10-07 00:21:34
 * @Description: 
 * Copyright (c) 2025 by XAUT NEXT-E/ziyu, All Rights Reserved. 
-->

::: note TODO:

文档待完善！

:::

## 1. OpenCV简介

### 1.1 什么是OpenCV？

OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，包含了数百种计算机视觉算法。它就像给计算机装上了"眼睛"，让程序能够看懂图片和视频。

‍

### 1.2 OpenCV能做什么？

- 读取、显示、保存图片/视频
- 特征检测（人脸、边缘、角点）
- 目标跟踪和识别
- 测量和几何变换

  ‍

### 1.3 为什么选择OpenCV？

- ​**免费开源**：完全免费，商业可用
- ​**跨平台**：Windows、Linux、Mac都能用
- ​**多语言支持**：C++、Python、Java等
- **功能强大**：从简单到复杂的视觉任务都能完成

  ‍

## 2. 图像的读取与显示

### 2.1加载并显示一张图片

Mat是矩阵，是OpenCV中的基本数据结构，用于存储图像数据，是一个多维数组，可以是一维、二维、三维等，用于存储图像的像素值，图像的宽、高、通道数等信息

```c++
#include <opencv2/opencv.hpp>
 
int main(int argc, char** argv) {
 
	cv::Mat img = cv::imread("C:/Resources/image/tifa_1.jpg");	// 读取图像
	if (img.empty())
	{
		std::cout << "Could not open or find the image" << std::endl;
		return -1;
	}
	cv::imshow("Image", img);					// 显示图像，窗口名为"Image"
	cv::waitKey(0);								// 等待按键，0表示无限等待
	return 0;
}
```

‍

### 2.2窗口自由调整

上面图片受限屏幕大小显示不完全

通过函数 namedWindow 来调整，让窗口大小可以自由调整

```c++
#include <opencv2/opencv.hpp>
 
int main(int argc, char** argv) {
 
	cv::Mat img = cv::imread("C:/Resources/image/tifa_1.jpg");	// 读取图像
	if (img.empty())
	{
		std::cout << "Could not open or find the image" << std::endl;
		return -1;
	}
	cv::namedWindow("Image", cv::WINDOW_FREERATIO);	// 创建一个窗口，窗口名为"Image"，窗口属性为自由比例
	cv::imshow("Image", img);						// 显示图像，显示在"Image"窗口上
	cv::waitKey(0);									// 等待按键，0表示无限等待。参数为等待时间，单位为ms
	cv::destroyAllWindows();						// 销毁所有窗口
	return 0;
}
```

### 2.3图像的读取方式

图像的读取方式  
    IMREAD_UNCHANGED：读取原图像，包括alpha通道  
    IMREAD_GRAYSCALE：以灰度图像读取  
    IMREAD_COLOR：以彩色图像读取  
    IMREAD_ANYDEPTH：以原图像深度读取  
    IMREAD_ANYCOLOR：以原图像颜色格式读取  
    IMREAD_LOAD_GDAL：使用GDAL读取图像  
    IMREAD_REDUCED_GRAYSCALE_2：以1/2的灰度图像读取  
    IMREAD_REDUCED_COLOR_2：以1/2的彩色图像读取  
    IMREAD_REDUCED_GRAYSCALE_4：以1/4的灰度图像读取

#### 加载图像的灰度图

‍

```c++
	cv::Mat img = cv::imread("C:/Resources/image/tifa_1.jpg",cv::IMREAD_GRAYSCALE);	
// 读取图像,参数为图像路径和读取方式
```

![image](https://free.picui.cn/free/2025/10/07/68e3edee81d2c.png)

## 3.图像色彩空间转换

创建一个TestDemo来管理实现后续的功能

### 3.1色彩转化

cpp

```c++
#pragma once
#include<opencv2/opencv.hpp>
 
using namespace cv;
 
class TestDemo
{
public:
	TestDemo();
	~TestDemo();
	void colorSpace_demo(Mat& image);	// 颜色空间转换,传入图像引用
};
```

‍

```c++
#include "TestDemo.h"
 
TestDemo::TestDemo()
{
}
 
TestDemo::~TestDemo()
{
}
 
void TestDemo::colorSpace_demo(Mat& image)
{
	cv::Mat gray, hsv, ycrcb;  // 定义三个 Mat 类对象
 
	//创建三个窗口，窗口名分别为"Gray"、"HSV"、"YCrCb"，窗口属性为自由比例
	cv::namedWindow("Gray", cv::WINDOW_FREERATIO);
	cv::namedWindow("HSV", cv::WINDOW_FREERATIO);
	cv::namedWindow("YCrCb", cv::WINDOW_FREERATIO);
 
	//转换图像颜色空间
	cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);		// 将图像转换为灰度图
	cv::cvtColor(image, hsv, cv::COLOR_BGR2HSV);		// 将图像转换为 HSV 图
	cv::cvtColor(image, ycrcb, cv::COLOR_BGR2YCrCb);	// 将图像转换为 YCrCb 图
 
	// 显示转换后的图像
	imshow("Gray", gray);
	imshow("HSV", hsv);
	imshow("YCrCb", ycrcb);
 
	// 保存转换后的图像
	cv::imwrite("C:/Resources/image/gray.jpg", gray);
	cv::imwrite("C:/Resources/image/hsv.jpg", hsv);
	cv::imwrite("C:/Resources/image/ycrcb.jpg", ycrcb);
 
}
```

```C++
 
#include <iostream>
#include <opencv2/opencv.hpp>
#include "TestDemo.h"
 
int main(int argc, char** argv) {
 
	cv::Mat img = cv::imread("C:/Resources/image/tifa_1.jpg");	// 读取图像
	if (img.empty())
	{
		std::cout << "Could not open or find the image" << std::endl;
		return -1;
	}
	cv::namedWindow("Image", cv::WINDOW_FREERATIO);	// 创建一个窗口，窗口名为"Image"，窗口属性为自由比例
	cv::imshow("Image", img);						// 显示图像，显示在"Image"窗口上
 
	TestDemo testDemo;								// 创建一个 TestDemo 类对象
	testDemo.colorSpace_demo(img);					// 调用 TestDemo 类的 colorSpace_demo 函数
 
	cv::waitKey(0);									// 等待按键，0表示无限等待。参数为等待时间，单位为ms
	cv::destroyAllWindows();						// 销毁所有窗口
	return 0;
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edef03e33.png)

    gray是灰度图，hsv是HSV图，YCrCb是YUV的变种

    g 0-255, b 0-255, r 0-255, 分别表示灰度、蓝色、绿色、红色  
    H 0-180 S 0-255 V 0-255, 分别表示色调、饱和度、亮度  
    Y 0-255 Cr 0-255 Cb 0-255, 分别表示亮度、红色色度、蓝色色度

YCrCb是YUV的变种，YUV是彩色视频信号的编码方式，Y表示亮度，U和V表示色度

### 3.2 保存图像

```C++
	// 保存转换后的图像
	cv::imwrite("C:/Resources/image/gray.jpg", gray);
	cv::imwrite("C:/Resources/image/hsv.jpg", hsv);
	cv::imwrite("C:/Resources/image/ycrcb.jpg", ycrcb);
 
	//imwrite参数为保存路径，保存图像
```

### 3.3提取指定色彩范围区域inrange

```C++
void TestDemo::inrange_colorSpace_demo(Mat& image)
{
	cv::Mat hsv;
	cv::cvtColor(image, hsv, cv::COLOR_BGR2HSV);		// 将图像转换为 HSV 图
	namedWindow("hsv", WINDOW_FREERATIO);
	imshow("hsv", hsv);
 
	cv::Mat mask;
	//提取偏红色区域
	inRange(hsv, cv::Scalar(0, 43, 46), cv::Scalar(10, 255, 255), mask);
	// 提取指定色彩范围的区域,参数为输入图像、颜色下限、颜色上限、输出图像
 
 
	cv::namedWindow("mask", cv::WINDOW_FREERATIO);
	cv::imshow("mask", mask);
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edeeaf9e0.png)

## 4.图像像素的读写操作

```C++
void TestDemo::pixel_read_write(Mat& image)
{
	int width = image.cols;		// 获取图像宽度
	int height = image.rows;	// 获取图像高度
	int channels = image.channels();	// 获取图像通道数
 
	//for (int row = 0; row < height; row++)
	//{
	//	for (int col = 0; col < width; col++)
	//	{
	//		if (channels == 1)	//单通道，图像为灰度
	//		{
	//			int pv = image.at<uchar>(row, col);	// 获取像素值,at<uchar>表示获取灰度图像的像素值,取值范围为0-255
	//			image.at<uchar>(row, col) = 255 - pv;	// 修改像素值，取反
	//		}
	//		if (channels == 3) //三通道图像，彩色图像
	//		{
	//			Vec3b pv_bgr = image.at<Vec3b>(row, col);	// 获取像素值,at<Vec3b>表示获取彩色图像的像素值,bgr通道
	//			image.at<Vec3b>(row, col)[0] = 255 - pv_bgr[0];	// 修改像素值，取反,Vec3b[0]表示B通道
	//			image.at<Vec3b>(row, col)[1] = 255 - pv_bgr[1];	// 修改像素值，取反,G通道
	//			image.at<Vec3b>(row, col)[2] = 255 - pv_bgr[2];	// 修改像素值，取反,R通道
	//		}
 
	//	}
	//}
 
	//通过指针访问像素
	//指针访问像素
	for (int row = 0; row < height; row++)
	{
		uchar* data = image.ptr<uchar>(row);	// 获取图像第 row 行的指针
		for (int col = 0; col < width; col++)
		{
			if (channels == 1)	//单通道，图像为灰度
			{
				*data++ = 255 - *data;	// 修改像素值，取反
			}
			if (channels == 3) //三通道图像，彩色图像
			{
				*data++ = 255 - *data;	// 修改像素值，取反,B通道
				*data++ = 255 - *data;	// 修改像素值，取反,G通道
				*data++ = 255 - *data;	// 修改像素值，取反,R通道
			}
		}
	}
 
 
	namedWindow("pixel_read_write", WINDOW_FREERATIO);
	imshow("pixel_read_write", image);
 
 
}
```

## 5.通道分离与合并

```C++
void TestDemo::channel_demo(Mat& image)
{
	Mat bgr[3];
	split(image, bgr);	// 通道分离
	namedWindow("B", WINDOW_FREERATIO);
	namedWindow("G", WINDOW_FREERATIO);
	namedWindow("R", WINDOW_FREERATIO);
	imshow("B", bgr[0]);
	imshow("G", bgr[1]);
	imshow("R", bgr[2]);
 
	Mat dst;
	bgr[1] = 0;			// 将 G 通道置为 0
	bgr[2] = 0;			// 将 R 通道置为 0
	merge(bgr, 3, dst);	// 通道合并
	namedWindow("channel_demo", WINDOW_FREERATIO);
	imshow("channel_demo", dst);
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edeee3461.png)

## 6.几何形状绘制

```cpp
 
void TestDemo::draw_demo()
{
	//创建一个白色底板的图像
	Mat image = Mat::zeros(Size(512, 512), CV_8UC3);
	image = Scalar(255, 255, 255);
 
	//绘制直线
	line(image, Point(100, 100), Point(200, 200), Scalar(0, 0, 255), 2, LINE_8, 0);
	// 直线绘制,颜色为红色,线宽为2,线型为8连通,起点坐标为(100,100),终点坐标为(200,200)
 
	//绘制矩形
	rectangle(image, Rect(200, 200, 100, 100), Scalar(0, 255, 0), 2, LINE_8, 0);
	// 矩形绘制,颜色为绿色,线宽为2,线型为8连通,矩形左上角坐标为(200,200),宽高为100
 
	//绘制圆形
	circle(image, Point(300, 300), 50, Scalar(255, 0, 0), 2, LINE_8, 0);
	// 圆形绘制,颜色为蓝色,线宽为2,线型为8连通,圆心坐标为(300,300),半径为50
 
	//绘制椭圆
	ellipse(image, Point(400, 400), Size(100, 50), 0, 0, 360, Scalar(255, 255, 0), 2, LINE_8, 0);
	// 椭圆绘制,颜色为黄色,线宽为2,线型为8连通,椭圆中心坐标为(400,400),长轴宽度为100,短轴宽度为50
 
	//绘制多边形
	std::vector<Point> points;
	points.push_back(Point(100, 400));
	points.push_back(Point(200, 300));
	points.push_back(Point(300, 400));
	points.push_back(Point(400, 300));
	points.push_back(Point(500, 400));
	const Point* ppt[1] = { points.data() };
	int npt[] = { points.size() };
	fillPoly(image, ppt, npt, 1, Scalar(0, 255, 255), LINE_8, 0);
 
	//显示图像
	namedWindow("draw_demo", WINDOW_FREERATIO);
	imshow("draw_demo", image);
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edede75bf.png)

在图像上绘制

```C++
void TestDemo::draw_demo(Mat& image)
{
	//在图像的人脸上绘制矩形
	Mat img = image.clone();
	rectangle(img, Rect(380, 400, 700, 700), Scalar(0, 255, 0), 3, 0, 0);
 
	//显示图像
	namedWindow("draw_demo", WINDOW_FREERATIO);
	imshow("draw_demo", img);
 
	//保存图像
	imwrite(image_path + "/draw_demo.jpg", img);
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edf11fb64.png)

## 7.视频文件/摄像头使用

```C++
void TestDemo::video_demo()
{
	VideoCapture capture(0);	// 打开摄像头
	if (!capture.isOpened())	// 摄像头打开失败
	{
		std::cout << "摄像头打开失败" << std::endl;
		return;
	}
 
	Mat frame;
	while (1)
	{
		capture >> frame;	// 读取摄像头图像
		//翻转摄像头显示
		flip_demo(frame, 1);
		imshow("video_demo", frame);	// 显示摄像头图像
		if (waitKey(30) == 27)	// 按下 ESC 键
		{
			break;
		}
	}
	capture.release();	// 释放摄像头
	destroyAllWindows();	// 销毁所有窗口
}
```

## 8.视频处理与保存

```C++
	//保存视频
	VideoWriter writer;
	writer.open(image_path + "/video_demo.avi", VideoWriter::fourcc('M', 'J', 'P', 'G'), 25, Size(frame.cols, frame.rows));
	while (1)
	{
		capture >> frame;	// 读取摄像头图像
		writer.write(frame);	// 写入视频
		imshow("video_demo", frame);	// 显示摄像头图像
		if (waitKey(30) == 27)	// 按下 ESC 键
		{
			break;
		}
	}
	writer.release();	// 释放视频
```

## 9.图像卷积操作

‍

图像卷积是图像处理中的一种基本操作，它通过在图像上滑动一个卷积核（也称为滤波器或窗口），对图像的每个像素进行加权和的操作。这一过程可以用来实现一系列的图像处理任务，如模糊、锐化、边缘检测等。下面是图像卷积的基本原理和步骤：

**原理：**   
**卷积核**： 卷积核是一个小矩阵，包含了一组权重值。卷积操作时，卷积核在图像上滑动，与图像中的每个像素进行加权和的计算。

**加权和计算**： 对于图像中的每个像素，卷积核与图像的对应区域进行逐元素相乘，然后将所有乘积结果相加，得到最终的加权和。

**滑动操作**： 卷积核在图像上滑动，对每个像素都进行加权和的计算，得到新的图像。

**步骤：**   
**定义卷积核：**  确定卷积核的大小和权重。

**图像填充**： 可选的步骤，对图像进行填充，以保留边缘信息。

**卷积操作：**  卷积核在图像上滑动，对每个像素进行加权和的计算。

**输出结果：**  得到卷积后的图像，即输出结果。  

```C++
void TestDemo::convolution_demo(Mat& image)
{
	//创建一个白色底板的图像
	Mat img = Mat::zeros(Size(512, 512), CV_8UC3);
	img = Scalar(255, 255, 255);
 
	//图像卷积操作
	Mat kernel = (Mat_<float>(3, 3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);	// 创建卷积核
	Mat dst;
	filter2D(image, dst, -1, kernel);	// 图像卷积
	namedWindow("convolution_demo", WINDOW_FREERATIO);
	imshow("convolution_demo", dst);
}
```

## 10.高斯模糊

高斯模糊（Gaussian Blur）是一种常用的图像模糊技术，它使用高斯函数对图像进行卷积，从而实现图像平滑处理。高斯模糊的主要目的是去除图像中的高频噪声，使图像更加平滑，减少细节信息，常用于图像预处理、边缘检测前的图像平滑等任务。

**高斯模糊的原理：**   
**高斯函数：**  高斯函数是一种数学函数，通常用于表示正态分布。在图像处理中，高斯函数用于生成一个二维的高斯核（卷积核）。

**卷积操作：**  高斯核在图像上滑动，对图像中的每个像素进行加权和的计算。不同位置的像素受到的权重由高斯函数的形状决定，距离中心越远的像素权重越小。

**权重计算：**  高斯函数的形状由标准差（σ）决定，标准差越大，权重分布越广。权重计算采用二维高斯函数的值，将其归一化，得到最终的权重。

**高斯模糊的步骤：**   
**定义高斯核：**  定义一个二维高斯核，指定标准差。

**图像卷积：**  将高斯核与图像进行卷积操作。

**输出结果**： 得到经过高斯模糊处理后的图像。  

```C++
void TestDemo::gaussian_blur_demo(Mat& image)
{
	// 定义高斯核大小和标准差
	int kernel_size = 35;
	double sigma = 35;
 
	// 高斯模糊
	Mat dst;
	GaussianBlur(image, dst, Size(kernel_size, kernel_size), sigma);
	//GaussianBlur参数为输入图像、输出图像、高斯核大小、标准差
 
	namedWindow("gaussian_blur_demo", WINDOW_FREERATIO);
	imshow("gaussian_blur_demo", dst);
 
}
```

![image](https://free.picui.cn/free/2025/10/07/68e3edf42394c.png)

‍